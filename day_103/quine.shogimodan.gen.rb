# coding: UTF-8

# 変数の使い方
# $1: 1 固定
# $2: 2 固定
# $3: モード (3: データ出力、2: コード出力、1: 終了)
# $4: ▲と△の切り替えフラグ
# $5: ループカウンタ
# $6: リターン先ラベル保持
# $7, $8, $9: 雑多

# 指定した文字のコード番号を計算して出力するコードを生成する
# $7 と $8 を使い、$8 に結果を入れて返す
# accum が真なら $8 を初期化しないで計算する
def output(ch, accum = false)
  c = ""
  c = "▲８八金 (* $8 -= $8 *)" unless accum
  c << "▲７一と (* $7 = $1 *)"
  ch.unpack("U").first.to_s(2)[1..-1].reverse.each_char do |n|
    c << "▲８七歩 (* $8 += $7 *)" if n == "1"
    c << "▲７二銀 (* $7 *= $2 *)"
  end
  c << "▲８七歩 (* $8 += $7 *)" if ch != "\0"
  c << "▲８一玉 (* putc $8 *)"
  c
end

# ▲と△を交互に出力するコード断片
output_player = <<END
# $4 を反転させる (4 -> 0 -> 4 -> 0 -> ...)
▲８一と ▲８二金          # $8 = -1
▲４二金 ▲４八銀 ▲４二歩 # $4 = ($4 - $2) * $8 + $2

# $8 に加算分を入れる (1 -> 0 -> 1 -> 0 -> ...)
▲８四と ▲８二桂 ▲８二桂 # $8 = $4 / 4

# ▲か△を出力する
#{ output("▲", true) } # putc ▲
END

code = <<END.gsub(/#.*|\(\*(?:.|\n)*?\*\)|[+\-|>^]/, "").split.join(" ")
##### データ部分 (後でコード部分から生成する) #####

    # ラベル 6 からスタート
    #*6

    # 文字のコード番号を 1 ビットずつ 16 ビット push する (little endian)
    #▲１一龍 ▲２一龍 ▲１一龍 ▲１一龍 # push $1; push $2; ...
    #▲１一龍 ▲１一龍 ▲２一龍 ▲１一龍
    #▲１一龍 ▲１一龍 ▲１一龍 ▲１一龍
    #▲２一龍 ▲２一龍 ▲１一龍 ▲１一龍

    # 文字を処理するサブルーチンを呼び出す (ラベル 2 へジャンプ)
    # (リターン先ラベルは $6 に入っている)
    #▲１二飛 # jump_if $1 $2

    # 以上で 1 文字の処理が終了、以降全文字分繰り返し

    # ...


##### コード部分 #####

    # 全データを処理した
    #*?

    # モードを進めてデータ部分の先頭に戻る (ラベル 6 へジャンプ)
    ▲３一金                   # $3 -= 1
    ▲６二と ▲６二歩 ▲６二歩 # $6 = 6
    ▲６六飛                   # jump_if $6 $6


    ### 文字を処理するサブルーチン

# リターン
^
|       *2
|       # push されたビット列データをデコードする (16 ビットを pop して整数に戻す)
|       # $9 に戻した整数を記録する
|       # $8 はビット演算用 (1<<16)
|       # $5 はループカウンタ (16)
|       ▲９九金                                     # $9 = 0
|       ▲８二と ▲８八銀 ▲８八銀 ▲８八銀 ▲８八銀 # $8 = 1<<16
|       ▲５二と ▲５五銀 ▲５五銀                   # $5 = 16
|
|       # デコードのループ
|   +-> *4
|   |   # $8 を右シフトしながら、pop した値が 2 だったら $9 に $8 を足す
|   |   ▲８二桂                   # $8 /= 2
|   |   ▲７一馬 ▲７一金 ▲７八銀 # $7 = $8 * (pop - 1)
|   |   ▲９七歩                   # $9 += $7
|   |
|   |   # ループカウンタをデクリメントし、ループの先頭にジャンプする
|   |   ▲５一金          # $5 -= 1
|   |   ▲７二と ▲７二歩 # $7 = 4
|   +-- ▲５七飛          # jump_if $5 $7
|   |
|   +-> # この時点で $9 にはデコード結果が保持されている
|
|       # 現在のモードに基づいてディスパッチする
| +---- ▲８三と ▲８二金 ▲８三飛 # $8 = $3 - $2; jump_if $8 $3
| |
| |
| +---> ### 現在のモードは 2 (コード部分出力)
| |
| |     # デコードした文字をそのまま出力する
| |     ▲９九玉 # putc $9
| |
| |     # リターン先ラベルを 1 つ進めてジャンプする (リターンする)
+-+---- ▲６一歩 ▲６六飛 # $6 += 1; jump_if $6 $6
| |     # assert false
| |
| |
| +---> *3
| |     ### 現在のモードは 3 (データ部分出力)
| |
| |     # ラベルの文字列を出力する (ex. "*6 ")
| |     #{ output("*") } ▲６一王 #{ output(" ") } 
| |
| |     # エンコードする (little endian で 1 ビットずつ push するコードを出力する)
| |     # $5 はループカウンタ (16)
| |     ▲５二と ▲５五銀 ▲５五銀 # $5 = 16
| |
| | +-> *5
| | |   # push するコードを出力する (ex. "▲１一龍 ")
| | |   #{ output_player }
| | |
| | |   # $8 に $9 の最下位ビットを代入し、$9 を右シフトする
| | |   ▲８九と ▲８二香 ▲９八金 ▲９二桂 # $8 = $9; $8 %= $2; $9 -= $8; $9 /= 2
| | |
| | |   #{ output("１", true) } # putc $8
| | |   #{ output("一") + output("龍") + output(" ") }
| | |
| | |   # ループカウンタをデクリメントし、ループの先頭にジャンプする
| | |   ▲５一金                   # $5 -= 1
| | |   ▲７二と ▲７二歩 ▲７一歩 # $7 = 4
| | +-- ▲５七飛                   # jump_if $5 $7
| | |
| | +-> # サブルーチンを呼び出すコードを出力する ("１二飛 ")
| |     #{ output_player }
| |     #{ output("１") + output("二") + output("飛") + output(" ") } # putc "１二飛 "
| |
| |     # リターン先ラベルを 1 つ進めてジャンプする (リターンする)
+-+---- ▲６一歩 ▲６六飛 # $6 += 1; jump_if $6 $6
  |     # assert false
  |
  |
  +---> *1
        ### 現在のモードは 1 (終了)

        # 改行を出力して終了する
        #{ output("\n") }
END


# コード部分の先頭にラベルを付ける (ラベル番号はコード長に依存する)
code = "*#{ (code.size + 6 + 6) } " + code

# コード部分の▲△を交互にする (飾り)
flag = (code.size % 2) == 0
code.gsub!(/[▲△]/) { (flag = !flag) ? "△" : "▲" }

# コード部分からデータ部分を生成する
data, label = "", 6
code.unpack("U*").each do |ch|
  data << "*#{ label } "
  label += 1
  ("%016b" % ch).reverse.chars.each do |n|
    data << "▲#{ n == "0" ? "１" : "２" }一龍 "
  end
  data << "▲１二飛 "
end

# コード部分の先頭にデータ部分をつける
code = data + code
flag = true

# 全体の▲△を交互にする (飾り)
code.gsub!(/[▲△]/) { (flag = !flag) ? "△" : "▲" }

puts code
